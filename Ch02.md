### 2. 알아 두어야 할 자바스크립트

ES -ECMAScript  
ES2015 - ES6

2.1 ES2015+
2015년 발표 자표스크립트 표준 문법안 : 상당히 변화함
2016년 승인 후 ES6

babel : 구형 브라우저에서 ES6를 돌아가게 해주는 도구

### 2.1.1 const, let

- var: 변수 선언 (옛날에 쓰던 거);
  --> const, let 대체
- var의 단점: Hoisting
  ---> 변수 선언이 아무곳에서 이뤄져서 소스 코드 이해도가 떨어짐 --> 가독성이 안 좋다.
  var: 함수 스코프  
  let, const : 블록 스코프 - 함수,if,while등등 { // block };
  로컬 스코프와 글로벌,전역 스코프

let: 재할당 가능, 선언할떄 초기화 안 해도 됨  
const : 재할당하면 런타임 에러 발생, 선언 할 때 반드시 초기화를 해줘야함

### 2.1.2 템플릿 문자열

문자열 - "", ''  
백틱 템플릿 문자열 - `` ${}를 넣어서 변수나 함수 사용이 가능,  
문자열 안에 "나 '를 넣기 편함 \' \" escape 문자를 사용 안해 됨

### 2.1.3 객체 리터럴

**literal**: 구체적인 값  
1,123,"name"  
**object literal** : 생선되 객체, 실행 도중에 객체의 속성과 메소드를 동적으로 추가 가능하다.

- 이전 버전 :
- 최신 버전 : 속성 명에 변수 가능

### 2.1.4 arrow Function

function add1 ( x,y){
return x + y ;
}  
const add2 = (x,y) => {return x + y;}
const plus1 = x => x+1; // 명령문이 한 줄 이면 return도 생략 가능

function not1(x){ return !x};
-->
const not2 = x =!x;

**arrow 함수의 this bind 방식**  
기존 방식의 함수의 경우에는, old 함수 내부의 {} 블록 스코프 내에서 쓰이는 this는 전역 변수를 가리킨다.  
arrow 함수의 경우에는 전역 변수가 아닌, new 함수의 { } 밖의 스코프에는 상위 this를 상속 받아 사용한다.
구형 함수가 객체 안의 프로퍼티로들어가서, 객체 안에서의 함수로서

### 2.1.5 구조분해할당

- old  
   객체, 배열로 부터 속성 또는 요소 접근
  객체명.속석명 ---> 객체명[속성명]
  배열명[인덱스]
  대입의 왼쪾에는 리터럴이나 수식 사용이 불가능 했다.

- new
  구조 분해 할당이 가능해짐
  : 는 새로운 이름, = 기본값 할당이 가능함.

### Class : 클래스 문법은 ES6에서 객체 도입

- 자바스크립트를 학술적으로는 객체 지향 언어라 하지 않음
- 객체 중심 언어, 프로토타입 기반 언어 (**Prototype** Based Language)
  Classless Language, Instance Based Language
- 프로토타입 : 원형 - 객체를 사용하는데, 객체의 원형만 있고 실행 도중에 속성, 메소드를 추가 또는 삭제가 가능함
- 상속, 다형성 구현이 가능하나 매우 어려움

### 2.1.7 프로미스: Promise

- 프로미스 이전의 비동기 : 콜백 처리 , I/O 작업에는 콜백 함수가 쓰인다.
  ES6 부터는 프로미스 사용을 권장
- 반드시 알아야 할 중요 객체
- 비동기 처리에서 성공, 실패의 경우를 나눠서 구현
- 프로미스 사용 이유 또는 문법 개발 배경: 콜백 지옥 현상을 극복
  **사용 방법**

1. 프로미스 객체 생성
2. 생성된 객체에 then(), catch() , finally() 메소드를 호출  
   3개의 메소드의 매개변수 : 콜백 함수로 구현 ;
   resolve( ) 호출 -> then( ) 실행  
   reject() 호출 --> catch () 실행
   호출하건 호출 안 하건 finally() 반드시 실행

~77 페이지 콜백을 프로미스로 변경
